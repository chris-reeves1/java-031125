Containers intro:

- A container is a process. 

- it's like a virtual machine - os/ephemeral/install+config like a vm. 

- description:
    - self-contained apps/dependancies
    - independence from OS?????? sudo always has visabilty and control. 
    - isolation - processes/
    - works on any env/os
    - scalbility
    - availability
    - micro-services
    - serverless. 


namespaces:
    - mnt: "what can i see"
    - pid: "who am i"
    - net: "how to communicate"
    - IPC: "sharing + permissions"
    - uts: "what name is shown for me"
    - cgroups: "how much mem + cores can i have"
    
    - user: "identity"
    - time: "what is the time"

namespace = what am i aware of.

lsns:

output:
    -   ns: inode number - kernal tracks ns's with it. Shows global ns's.
    -   nprocs - number of processes - filtered by ubuntu's capabilities.
    -   PID - actual numbers
    -   sh - a representitive command.


sudo lsns:
    - full view of the system. 
    - udevd process has an isolated mnt namespace!

explore the ubnutu processes:
    ps -U ubuntu

nsenter: 
- we'll enter the namespace for 1361 and see the world through its eyes. 
- only use namespaces it actually uses or error!!

- nsenter -t <pid number> -m -u -i -n -p /bin/bash - showed all processes as in gloabl ns's.

To enter a isolated ns lets make one with unshare:

unshare:

nesting - allowed but be aware of permissions. 

--pid: isolating the PID ns
--fork duplicate the command so we have a process running in the pid tree. 

is isolation worth it:
    without:
        - every process shares 1 filesystem/pid/network
        - any bug or breach affects all.
        - cant constrain cpu/mem usage.
        - lose repreoducability. 
    with:
        - each service believes its alone.
        - resources limited (reduces noisy affect)
        - package the env run it anywhere.

ns + docker process will stop if no long running process lie within.

better example: 

apt install debootstrap
debootstrap --variant=minbase noble /rootfs http://archive.ubuntu.com/ubuntu/

chroot (change root)

unshare --mount --pid --net --ipc --uts --fork --root=rootfs --mount-proc /bin/bash

good series of videos on youtube by Datadog:
https://www.youtube.com/watch?v=BwI89OnYm-4



-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------



1) install docker

    curl https://get.docker.com | sudo bash

then optionally:

    sudo usermod -aG docker ubuntu

Check its working ok:
    docker run --rm hello-world

2) image name construction

    [HOST]/[USER]/[NAME]:[TAG]

HOST: defaults to dockerhub.io (alternatives cloud registry, nexus, private server)
USER: unofficial users need their username in the image name. Otherwise can be empty.
NAME: just a name. 
TAG: any metadata tag: v10.10.11, python/java, os, - if empty defaults to "latest". 

3) image commands
    - docker images                  - see downloaded images
    - docker rmi <image-name>          - delete the image
    - docker rmi -f $(docker images)    - delete all images
    - docker tag <old> <new>      - rename image to tag username then push to registry. 
    - docker push <name>        -- push to registry command
    - docker search <name>        - searches dockerhub
    - docker pull <name>        - manually pull an image from dockerhub. 

4) run a container

    docker run -d -p 80:80 --name nginxwebserver nginx

    -d     --detatched mode  - doesnt tka eover our temrinal
    -p     --publish - for publiushing ports. 
            first number is host port and can be any open, free port.
            second is app port and determined by the process/app running. 
    --name     - names the actual container (optional)
    last arg = the image name to use.
    -e    -- pass through env vars
    --network  --attach to a specific network
    -v    - mounts for persistant data storage. 


    docker ps    - shows all running containers
    docker ps -a   - show all container running or stopped. 
    docker rm -f $(docker ps -aq) -- delete all containers 
    docker exec -it <name> bash - enter the container. 

    docker stop <name>
    docker start <name>
    docker rename <old> <new>

    docker logs <name>
    docker inspect <name>

6) build a custom image

    docker build -t name . 

    -t   -- name tag
    .    -- build context - points to the dockerfile. 

inside the Dockerfile:
    FROM - base layer (always an image -- usually official)
    WORKDIR
    COPY - copies files to a location in the container. 
    RUN - run linux commands in the container. 
    ENV
    EXPOSE
    CMD
    ENTRYPOINT
    VOLUME
    USER
    ARG
    HEALTHCHECK
    LABEL